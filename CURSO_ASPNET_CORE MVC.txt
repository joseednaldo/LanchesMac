#######################
CURSO UDEMY
#######################
launchSettings.json   	= configração do localhost
appsettings.json  		= arquivo de configração , seria o equivalente ao web.config.
Program.cs  			=  inicializa a aplicação onde é feita a configuração do host / servidor.
Startup.cs 				=  configura os servicos... que vai ser usado.

-- OBJETO CO MVC - BAIXO ACOPLAMENTO... 
MODEL 		-> RESPONSAVEL POR MANTER OS DADOS E A LÓGICA DE NEGOCIO DA APP.
VIEW 		-> INTERFACE COM O USUARIO DA APP QUE EXIBE OS DADOS.  
CONTROLLER  -> RECEBE E TRATA AS REQUISIÇÕES(DO BROWSER/USUARIO) E RENDERIZA A VIEW APROPRIADA COM OS DADOS.


MODELO DE MVC :
URL-> não é uma página.
-No modelo de desenvolvimento MVC uma "URL" corresponde a uma ação de um "controler" e não uma página em disco..
-No modelo de desenvolvimento MVC  as requisições do navegador (usuário) são mapeadas para "ações" do "CONTROLLER"

EX:
HTTP://LOCALHOST/HOME/INDEX 
HOME 	= CONTROLLER
INDEX 	= ACTION


###################FUNCIONAENTO DO PROJETO###############

ARQUIVO:
Startup: -> função -> ConfigureServico


PASTA SHARED  = ARQUIVOS / LAYOUT COMPARTILHADO EX: BARRA DE MENU.
TAMBÉM OS JS,JQUERY E BOOTSTRAP.


projeto.csproj = mostra as dependeças do projeto.


##########################################################

MIGRANDO - PARA VERSÃO 3.1 DO CORE.

##########
MODELO
##########
CRIANDO O MODELO DE DOMINIO
-SÃO AS CLASSES QUE REPRESENTAM A SUA LÓGICA DE NEGÓCIO.

###################################
	AULA 11 - ENTITY FRAMEWORK CORE
####################################
Ferramento que permite ao desenvolvedor trabalhar com dados relacionais na forma de objtos especificos do domonio.

OBJETOS     |   MAPEADOR OBJETO      / BANCO DE DADOS.


DBCONTEXT    						  |  DBSET
REPRESENTA BANCOD DE DADOS			 	TABELAS

LINQ -> DBCONTEXT  -> DBSET
	    DBCONTEXT  <- DBSET		

AÇÕES: DO ENTITY
ALTERAR,EXCLUIR E INCLUIR


############
CODE FISRT   /MODELO USAO NO RCI...
###########
CRIAMOS AS CLASSES DE DOMINIO E O ENTIRY FRAMEWORK CRIAR O BANCO/TABELAS


##############
DATABASE FISRT
##############
PARTIMOS DO BANCO DE DADOS JÁ EXISTENTES E USAMOS O ENTIRY FRAMEWORK CORE OARA GERAR AS CLASSES DE DOMINIO.

		
######################################################################
	AULA 12 - CONFIGURANDO O ENTITY FRAMEWORK CORE
#######################################################################
ADD PACOTES:
MICROSOFT.ENTITYFRAMEWORK.CORE 3.1.3.
MICROSOFT.ENTITYFRAMEWORK.SQLSERVER 3.1.3.
MICROSOFT.ENTITYFRAMEWORK.TOOLS 3.1.3.
Microsoft.VisualStudio.Web.CodeGeneration.Design 3.1.3.


DBCONTEXT 	=  REPRESENTA A SESSÃO COM O BANDO DE DADOS.
DBSET 		= REPRESENTA O MAPEAMENTO  PARA A TABELAS DO BANCO DE DADOS.

APPSETTING.JSON  = STRING DE CONEXÃO COM  BANCO DE DADOS.

###
	REGISTRAR NO ARQUIVO  "STARTUP" O CONTEXTO COMO SERVIÇO.
###
EX:
SERVICES.AddContext<AppDbContext>(
options = > options.UseSqlserver(Configation.GetConnectionString("DefaultConnection")))
)

Startup.cs:
onde configurações a contexto e conectionstring.


######################################################################
	AULA 13 - AJUSTE CONFIGURANDO O ENTITY FRAMEWORK CORE
#######################################################################


######################################################################
	AULA 14 - USANDO O DATA NOTATION
#######################################################################
Recurso usado para validar entrada de dados e também podemos usar 
com regra de negocio 
ex: validar cartão de crédito , cpf, email.


######################################################################
	AULA 15- AJUSTO DATA  NOTATION
#######################################################################
COLCOAR NAS PROPRIEDADE
[COLUMN(TypeName="decimal(18,2)")]
public decimal Preco {get;set;}


######################################################################
	AULA 16- USANDO EF  CORE MIGRATION
######################################################################
Gerencia o versionamento do banco de dados.

Métodos:
add-migration nome_migração        - cria script
update database       			   - aplica o script no sqlserver (banco)
remove-MIGRATION  = desfazer a ação feita.


######################################################################
	AULA 17- POPULANDO BANCO DE DODOS COM MIGRATION
######################################################################
USAMOS O MIGRATION PARA MANIPULAR AS TABELAS SEJA OS DADOS.
Criamos mi grationa -> 20200522204440_PopularTabelas
Os dados foi criando via migration.
Esse cenario é bom como quero criar paramentros de alguns tabelas de 
sistemas.

######################################################################
	AULA 17- AJUSTE - POPULANDO BANCO DE DODOS COM MIGRATION
######################################################################


######################################################################
	AULA 20- IMPLEMENTANDO O PADRÃO REPOSITORY
######################################################################

::  FLUXO REQUISIÇÕES  ::
SENARIO ACEITO - PARA DIMINUIR O ACOPLAMENTO.   "PADRÃO REPOSITORY"
[IIS] -----> [CONTROLLER] -----> [REPOSITORY] ----> [EF CORE] ---> (BANCO DE DADOS)

O QUE É O PADRAO [REPOSITORY]
È um padrão estrutural que separa a sua "lógica de dominio" da sua lógica de "acesso a dados".
Podemos usar o padrão REPOSITORY para desacoplar o "modelo de dominio" do código de acesso a dados.
Vantagens:
1-Desacopla a sua aplicação da lógica de acesso a dados.
2-centraliza o seu código para consultas  e acesso aos dados.
3-facilita os testes unitários.
4-Minimiza a duplicidade de codigo nas consultas.


:: COMO IMPLENTATAR O PADRAO REPOSITORY ::
Implementação.

[INTERFACE]										<--------------- [CLASSE  CONCRETA]  a classe concreta vai herda os metodos da interface
Na interface definotodos os metodos que vou usar.

Exemplo com os dominios - Lanche e Categoria
[ILancheRepository] 	<----- [LancheRepository]  		= HERDA A INTERFACE
[ICategoriaRepository] 	<----- [CategoriaRepository] 	= HERDA A INTERFACE



######################################################################
	AULA 20- IMPLEMENTANDO O PADRÃO REPOSITORY
######################################################################
[ILancheRepository] 	<----- [LancheRepository]  		= HERDA A INTERFACE
[ICategoriaRepository] 	<----- [CategoriaRepository] 	= HERDA A INTERFACE
Nesse contexto que esta referenciando o EF é o repository.


::: IMPORTANTISSIMO  ::
QUANDO USAMOS UMA "INTERFACE" PREISAMOS FAZER UM "INJEÇÃO DE DEPENCIA" PARA USA-LO NO CONTROLADOR.
OU DESEJA QUANDO "DEFINIMOS UMA INTERFACE E SUA IMPLEMENTAÇÃO" TEMOS QUE "REGISTRAR ISSO COMO UM "SERVIÇO"
PRA FAZER "INJEÇÃO DE DEPENCIA NO CONTROLLE".

::: COMO CRIAR O SERVIÇO.
    FAZEMOS ISSO NA CLASSE "Startup.cs"
	
TEMOS:
1-AddTransient  => Significa que o serviço vai ser criado cada vez que ele for solicitado.
3-AddSingleton  => Significa que vai ser criado na primeira que for solicitado. ou seja toda as as requisições vai ter esse mesmo objeto.
2-AddScoped  	=> Significa que o serviço é criado uma  vez pra cada solitação.


ex:
//Registrando como serviço minhas interfaces pra ser usado nos controles... 
//specified = especificado  / transient = transitorio
services.AddTransient<ICategoriaRepository, CategoriaRepository>();
services.AddTransient<ILancheRepository, LancheRepository>();

Apos isso , chamamos por denpencia o serviço no controller.

######################################################################
	AULA 21- CRIANDO CONTROLLER E VIEW PARA MOSTRAR OS LANCHES...
######################################################################
Criando a  injecção de pencendia entre contoller e serviço.

EX:
private readonly ILancheRepository _lancheRepository;
	private readonly ICategoriaRepository _categoriaRepository;

	public LancheController(ILancheRepository lancheRepository,
		ICategoriaRepository categoriaRepository)
	{
		//injeção de pendencia das interfaces...
		// quando o controlador for chamar ILancheRepository , como eu tenho um serviço registrado pra ele , vamos recuperar a instancia da implementação da interface => "lancheRepository"
		_lancheRepository = lancheRepository;
		_categoriaRepository = categoriaRepository;

	}
	

::: TIPOS DE RETORNO ::
IActionResult  = RETORNA UM ActionResult  QUE PODE SER UMA ViewREsult, pode ser diversoes tipos de retorno.


######################################################################
	AULA 22- AJUSTANDO O CODIGO DA  VIEW LIST
######################################################################
O QUE SIGNIFICA=>
@model IEnumerable<LanchesMac.Models.Lanche>
@model = Ultilizada para especificar o tipo que vamos usar na view.
No caso acima fala que esotu usando uma lista do tipo "lanches".
Outro exemplo de uso:
@using LanchesMac.Models
@model IEnumerable<Lanche>

@model => é apenas a doretiva que aponta para o tipo lanche.
Model  => é ultilizada apenas para acessar o tipo que é passada na view.
Ou seja permiti acesso ao "a lista do tipo lanche". è a properidade que acessa o tipo.

############################################################################
	AULA 23 QUAL O PAPEL DOS ARQUIVOS _ViweStart,_ViewImports e o BOOTSTRAP
############################################################################
-Layout.cshtml  = comum para todas as telas, ou seja é um arquivo que mostrado em 
todas as telas ex: rodade,footer etc...logo...menu
Carregamos os arquicos de style css..

No @RenderBody() = è onde as telas(views) é renderizada.

_ViweStart = È Através do _ViweStart que => as views sabe qual é o "arquivo de layout" que ele tem que utilizar.


_ViweImports.cshtml =   O objetivo dele é conter todas as referenças e import comum em todas as "VIEWS"
Ex:
@using LanchesMac   		= referencia o projeto 
@using LanchesMac.Models 	= referencia a model 
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers  = significa que a ultilização das tags helper estão habilitadas.

############################################################################
	AULA 24 			VIEW MODEL
############################################################################
É UM PADRÃO QUE PERMITE SEPARAR AS RESPONSABILIDADES  ENTRE MODELS DE DOMINIO
E OS MODELS QUE ATENDEM AS WIEWS.

PERMITE MODELAR ENTIDADES A PARTI DE UM OU MAIS MODELS EM UM UNICO OBJETO QUE SERÃO REPRESENTADOS
NA VIEWS.
"MODELS DE DOMONIO" REPRESENRA O MODELO DE NEGOCIO.

1-Senario  = Temos que apresenta a view informações oriundas de 2 ou mais modelos,
nesse cenario a "viewmodel" nos ajuda. Pode capsular varios models em um objeto.

BENEFICOS DA VIEWMODEL.
1-NAO PRECISA ALTERAR UMA CLASSE "MODEL"  PARA ATENDER AS NECESSIDADES DE UMA VIEW.
2-AGRUPAR INFORMAÇÇÕES  DE UMA OU MAIS "MODELS" EM UMA UNICA CLASSE, POUPANDO NECESSIDADE DE FAZER VARIAS CONSULTAS.
3-UM DADO NÃO CONTIDO NO "MODEL" DE DOMINIO PODE SER FIALCIMENTE TRANSPORTADO PARA VIEW MODEL.

############################################################################
	AULA 25 			IMPLEMENTANDO A VIEW MODEL
############################################################################
Posso usar nos meus controles a "viewmodel" para recuperar os dados , ao invés
de usar a "model" direta.
Ao invés de usar  a conexão direta com a model, podemos usar av viewmodel para
desacoplar.


############################################################################
	AULA 26 		PARTIAL VIEWS
############################################################################
UMA PARTIAL VIEW É UAM VIEW QUE É "RENDERIZADA" EM OUTRA => VIEW.
ELAS SÃO USADAS PARA ENCAPSULAR A LÓGICA REUTILIZADA NAS  VIEWS
PERMITINDO SIMPLIFICAR A COMPLEXIDADE DAS VIEWS.
ELAS PODEM SER USADAS EM MULTIPLAS VIEWS ONDE É NECESARIO
UMA LÓGICA SIMILAR EVITANDO ASSIM A DUPLICIADADE DE CODIGO.
-POSSUI A EXTENSÃO .CSHTML
-SAO RENDERIZADAS DE FORMA DIFERENTE (NÃO EXECUTAM _ViweStart.CSHTML

############################
REFERENCIANDO PARTIAL VIEWS
############################
Exemplo 1 => mais usual
@HTML.PARTIAL("NomeDaView")                           ->  Retorna um IHTMLSTRING

Exemplo 2Da
 Html.RenderPartial("NomeView");
} 
Não retorna um resultado. 
Transmite a saida renderizada diretamente para a resposta.


########################################
ACESSANDO DADOS NAS PARTIAL VIEWS
########################################
QUANDO UMA PARTIAL VIEW É INSTANCIADA ELA OBTÉM UMA CÓPIA DO VIEWDATA DA VIEW PAI.
EX:
@Html.Partial("NomeDaView", ViewData)
@Html.Partial("NomeDaView", model)

Podemos usar: partial,RenderPartial,PArtialAsybc e RenderPartialAsync
Obs:
As atualziações feitas nos dados da "PARTIAL VIEW", não são mantidas na view principal.
o viewdata alterado em uma partial view é perdido quando ela retorna.

########################################
LOCALIZANDO PARTIAL VIEWS
########################################

@Html.Partial("NomeView")=> usa a view autal na pasta com este nome, s enada for encontrado, procura naá
pasta shared.
@Html.Partial("NomeView.cshtml"), uma view com este nome deve existir na mesma pasta.
@Html.Partial("~/views/folder/NomeView.cshtml")=> Caminhos que iniciam com "/" ou "~/" refere-se á raiz da aplicação.


########################################
AUALA 27/28 - IMPLEMENTANDO PARTAIL VIEWS
########################################

A PARTI DA VERSÃO 3.1
TEMOS O JELP PARTIAL.
<PARTIAL NAME="_LanchesResumo" for="@lanche"/>

name=indica o noem ou caminho da partial view.
for=Atributo que permite passar um model para paetial view.


 
########################################
AULA - 29 CARRINHO DE COMPRA.
########################################
criamos a classe "carrinhoCompraIem"
e geramos o migration pra criar a tabela no banco.
add-migration "carrinhoCompraIem"
update-database  -- pra criar no banco...

##########################################
AULA - 30 SESSAO E O ESTADO DA APLICAÇAO.
##########################################

PROTOCOLO HTTP -  PROTOCOLO SEM ESTADO
ASP.NET  CORE
PACOTE DA MICROSOFT ->SESSION : MICROSOFT.ASPNETCORE.SESSION. 

COM BASE EM UM DICIONARIO OU TABELA HASH BO SERVIDOR, O ESTADO DA SESSÇAO PERSISTE OS DADOS ATRAVÉS DAS REQUISIÇÕES DE UM NAVEGADOR.
O ASP.NET CORE MANTEM O ESTADO DA SESSÃO , DANDO AO CLIENTE UM COOKIE QUE CONTEM UM "ID" DA SESSSÃO, QUE É ENVIADO AO SEEVIDOR COM CADA SOLICITAÇÃO.
PODEMOS USAR O "ESTADO DA SESSÃO" PARA GAURDA DADOS USUARIO ENQUANTO ELE NAVEGA NA APLICAÇÃO.

OS DADOS FICAM ARMAZENADO NO CACHE....]


OS COOKIE DE SESSÃO TEM UM TEMPO DE VIDA, SÃO EXCLUIDO QUANDO A SESSÃO DO NAVEGADOR TERMINA.


O SERVIDOR MANTEM UMA SESSÃO POR TEMPO LIMITADO APÓS A ÚLTIMA REQUISIÇÃO.
VOCE PODE DEFINIR O TEMPO LIMITE DA SESSÃO OU USAR O VALOR PADRÃO QUE É DE 20 MINUTOS.
O ESTADO DA SESSA~P É IDELA PARA ARMAZENAR DADOS DO USUÁRIO ESPECIFICO DE UMA DETERMINADA SESSÃO, FICAM NO CACHE
E VÃO SER EXCLUINDO QUANDO : A SESSÃO EXPIRAR OU SE USADI O RECURSO SESSION.CLEAR();

ONDE CONFIGURAMOS:
CLASSE "STARTUP" DEVE CONTER.   IDistributedCache
chamada da  => AddSession em configureSerevice()
chamada da  => UseSessin em configure()

ex:
Public void ConfigureServies(IServiceCollection services)
{
  //Adiona uma implementação padrão de IDistributedCache.
  servives.AddDistributedMemoryCache();
  services.AddSession();
}

public void Configure(IApplicationBuider app, IHosttingEnvironment){
	
	app.UseSession();
	app.Run(async(context)=>{
			
			await context.Response.WriteAsync(msg.GetMensagem());
	});
}

Exemplo de como armazena dados na sessão.

-criando variavaes
const string SessionKeyNome="_Nome";
const string SessionKeyIdade ="_Idade";

--Fazendo atribuições na sessão
httpContext.Session.SetString(SessionKeyNome,"ednaldo");
httpContext.Session.SetInt32(SessionKeyIdade,37);

--recuperando os dados da sessão.
var nome = context.Session.GetString(SessionKeyNome);
var idade = context.Session.GetString(SessionKeyIdade);


################################################
AULA - 31 IMPLEMENTANDO O CARRINHO DE COMPRAS
################################################
Configrando a session e serviços do carrinho.







################################################
AULA - 32 IMPLEMENTANDO O CARRINHO DE COMPRAS
################################################






















































